<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Map</title>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=6c266115501847fb26941efd997a1268&libraries=services"></script>
 <style>
    /* 지도 스타일 */
    #map {
        width: 100%;
        height: 600px; /* PC에서는 더 큰 높이 */
    }

    /* 입력 폼 컨테이너 가로 정렬 */
    .coordinates-input {
        margin-top: 20px;
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 15px;
        justify-content: flex-start;
        align-items: center;
        width: 100%;
    }

    /* 입력 필드 스타일 */
    .coordinates-input input,
    .coordinates-input select {
        width: 120px;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
    }

    /* 버튼 스타일 */
    .coordinates-input button {
        padding: 10px 10px;
        font-size: 1em;
        background-color: skyblue;
        color: black;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }

    .coordinates-input button:hover {
        background-color: DeepSkyBlue;
    }

    /* 결과 영역 스타일 */
    #result {
        margin-top: 20px;
        font-size: 1.2em;
        width: 100%;
    }
    /* 결과 표시 스타일 */
    .station-info {
        margin-top: 15px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 8px;
        background-color: #f9f9f9;
        font-size: 0.95em;
        color: #333;
        line-height: 1.6;
    }

    /* 강조 텍스트 스타일 */
    .station-info strong {
        font-size: 1em;
        color: #4CAF50;
        font-weight: 600;
    }

    /* 속성 구분자 스타일 */
    .station-info span {
        display: inline-block;
        margin-right: 10px;
    }

    /* 속성 값 스타일 */
    .station-info span.value {
        color: #555;
        font-weight: bold;
        font-size: 1.2em;
    }


        /* 오버레이 스타일 */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        /* 팝업 스타일 */
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            max-width: 500px;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 20px;
            z-index: 1000;
            overflow-y: auto;
            max-height: 50%;
        }

        .popup img {
            width: 100%;
            height: auto;
            margin-bottom: 10px;
            border-radius: 4px;
            transition: transform 0.3s ease;
            max-height: 50%;
        }

        /* 이미지 호버 효과 */
        .popup img:hover {
            transform: scale(1.05);
        }

        /* 팝업 헤더 */
        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        /* 닫기 버튼 스타일 */
        .popup-close {
            cursor: pointer;
            font-weight: bold;
            font-size: 15px;
        }

        /* 스크롤바 숨기기 */
        .popup::-webkit-scrollbar {
            display: none;
        }

    /* 모바일 스타일 */
    @media (max-width: 768px) {
        #map {
            height: 50vh; /* 모바일에서는 절반 높이 */
        }

        /* 모바일에서 세로 정렬 */
        .coordinates-input {
            flex-direction: column;
            align-items: flex-start;
        }

        .coordinates-input input,
        .coordinates-input select,
        .coordinates-input button {
            width: 100%; /* 모바일에서 전체 너비 사용 */
        }
    }
        .delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #ff4d4d;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 50%;  /* 원형 버튼 */
            font-weight: bold;
        }

        .delete-btn:hover {
            background-color: #ff0000;  /* 버튼 호버 효과 */
        }
    .map_wrap {
        position: relative;
        width: 100%;
        height: 500px;
    }
    #menu_wrap {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 100px;
        height: 170px;
        padding: 5px;
        overflow-y: auto;
        background: rgba(255, 255, 255, 1);
        z-index: 1;
        border-radius: 10px;
    }
    #map_wrap_bottom {
        position: fixed; /* 화면 하단에 고정 */
        bottom: 20px; /* 원하는 만큼 하단에 위치 */
        left: 0;
        width: 100%;
        height: 150px;
        padding: 5px;
        background: rgba(255, 255, 255, 1);
        z-index: 1;
        border-radius: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .map_options label, .map_routes label {
        display: block;
        margin: 5px 0;
        font-size: 10px;
    }
    .map_options_bottom label {
        margin: 0 5px; /* 가로 메뉴 간 간격 추가 */
        font-size: 15px;
    }
    </style>
</head>
<body>
    <div class="map_wrap">
        <div id="map" style="width:100%;height:150%;"></div>
        <div id="menu_wrap">
            <div class="map_options">
                <p><label>지도 정보:</label></p>
                <label><input type="checkbox" id="chkUseDistrict" onclick="setOverlayMapTypeId()" /> 지적편집도</label>
                <label><input type="checkbox" id="chkTerrain" onclick="setOverlayMapTypeId()" /> 지형정보</label>
                <label><input type="checkbox" id="chkTraffic" onclick="setOverlayMapTypeId()" /> 교통정보</label>
                <label><input type="checkbox" id="chkUseROADVIEW" onclick="setOverlayMapTypeId()" /> 로드뷰</label>
                <label><input type="checkbox" id="chkBicycle" onclick="setOverlayMapTypeId()" /> 자전거도로</label>
            </div>
        </div>
        <div id="map_wrap_bottom">
            <div class="map_options_bottom">
                <div id="result"></div>
                <div class="coordinates-input">
                    <label for="startLat">lat:</label>
                    <input type="text" id="startLat" readonly>

                    <label for="startLng">long:</label>
                    <input type="text" id="startLng" readonly>

                    <input type="text" id="startLatLng" readonly placeholder="선택 위치 정보" style="display: none;">

                    <button id="startAddressBtn">찾기</button>

                    <label for="name">역명:</label>
                    <input type="text" id="name">

                    <label for="line">노선:</label>
                    <input type="text" id="line">

                    <button id="resetButton">초기화</button>

                    <!-- This will show a message if the user doesn't select a position or line -->
                    <p id="lineInfoMessage" style="display:none; color: red;">기준 역을 선택해주세요!</p>
                    <br>
                    <select id="position">
                        <option value="before">전역에 추가</option>
                        <option value="after">다음역에 추가</option>
                    </select>
                        <button id="addStationButton">역 추가</button>
                        <button id="deleteStationButton">역 삭제</button>

                        <button id="showImagesButton">노선 정보</button>
                        <button id="addNewLineButton">신규 노선 추가</button>
                        <div class="overlay" id="overlay"></div>
                        <div class="popup" id="imagePopup">
                            <div class="popup-header">
                                <span>노선 이미지</span>
                                <span class="popup-close" id="closePopup">&times;</span>
                            </div>
                            <div id="imageList"></div>
                        </div>
                </div>

            </div>
        </div>
    </div>

    <script src="//t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js"></script>
{% load static %}
    <script>
    // 출발지 입력 필드에 포커스
    function focusStartField() {
        document.getElementById('startLatLng').focus();
    }
    var mapContainer = document.getElementById('map'),
        mapOption = {
            center: new kakao.maps.LatLng(37.566535, 126.9779692), // 지도 중심 좌표 (서울 시청)
            level:7 // 지도의 확대 레벨
        };


    var map = new kakao.maps.Map(mapContainer, mapOption);
    var geocoder = new kakao.maps.services.Geocoder(); // 주소-좌표 변환 객체 생성
<!--    mapContainer.style.opacity = "0.9"; // 투명도 설정 (0.0~1.0)-->
    // 지도 타입 정보를 가지고 있을 객체입니다
    // map.addOverlayMapTypeId 함수로 추가된 지도 타입은
    // 가장 나중에 추가된 지도 타입이 가장 앞에 표시됩니다
    // 이 예제에서는 지도 타입을 추가할 때 지적편집도, 지형정보, 교통정보, 자전거도로 정보 순으로 추가하므로
    // 자전거 도로 정보가 가장 앞에 표시됩니다
    var mapTypes = {
        terrain : kakao.maps.MapTypeId.TERRAIN,
        traffic :  kakao.maps.MapTypeId.TRAFFIC,
        bicycle : kakao.maps.MapTypeId.BICYCLE,
        useDistrict : kakao.maps.MapTypeId.USE_DISTRICT,
        useROADVIEW :  kakao.maps.MapTypeId.ROADVIEW
    };
<!--map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);-->
    // 체크 박스를 선택하면 호출되는 함수입니다
    function setOverlayMapTypeId() {
        var chkTerrain = document.getElementById('chkTerrain'),
            chkTraffic = document.getElementById('chkTraffic'),
            chkBicycle = document.getElementById('chkBicycle'),
            chkUseDistrict = document.getElementById('chkUseDistrict'),
            chkUseROADVIEW = document.getElementById('chkUseROADVIEW');

        // 지도 타입을 제거합니다
        for (var type in mapTypes) {
            map.removeOverlayMapTypeId(mapTypes[type]);
        }

        // 지적편집도정보 체크박스가 체크되어있으면 지도에 지적편집도정보 지도타입을 추가합니다
        if (chkUseDistrict.checked) {
            map.addOverlayMapTypeId(mapTypes.useDistrict);
        }

        // 지형정보 체크박스가 체크되어있으면 지도에 지형정보 지도타입을 추가합니다
        if (chkTerrain.checked) {
            map.addOverlayMapTypeId(mapTypes.terrain);
        }

        // 교통정보 체크박스가 체크되어있으면 지도에 교통정보 지도타입을 추가합니다
        if (chkTraffic.checked) {
            map.addOverlayMapTypeId(mapTypes.traffic);

        }

        // 로드뷰 체크박스가 체크되어있으면 지도에 로드뷰정보 지도타입을 추가합니다
        if (chkUseROADVIEW.checked) {
                map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW)
        }

        // 자전거도로정보 체크박스가 체크되어있으면 지도에 자전거도로정보 지도타입을 추가합니다
        if (chkBicycle.checked) {
            map.addOverlayMapTypeId(mapTypes.bicycle);
        }


        // 지도 드래그, 줌 가능 여부를 설정 (모바일에서 활성화)
        map.setDraggable(true); // 드래그 가능하도록 설정
        map.setZoomable(true);  // 줌 가능하도록 설정

        // 이중 터치 확대 방지 (모바일의 확대 제스처 충돌 방지)
        mapContainer.addEventListener('touchstart', function(event) {
            if (event.touches.length > 1) {
                event.preventDefault(); // 이중 터치 확대 방지
            }
        }, { passive: false });
    }

    // 지도에 교통정보를 표시하도록 지도타입을 추가합니다
<!--    map.addOverlayMapTypeId(kakao.maps.MapTypeId.TRAFFIC);-->
    var clickCount = 0;

    // URL에서 좌표 파라미터를 받아서 지도 중심 이동
    var urlParams = new URLSearchParams(window.location.search);
    var lat = urlParams.get('lat');
    var lng = urlParams.get('lng');

    if (lat && lng) {
        var moveLatLon = new kakao.maps.LatLng(lat, lng);
        map.setCenter(moveLatLon); // 파라미터로 전달받은 좌표로 지도 중심 이동
    }


    // 선택 좌표를 URL에 추가하는 함수
    function updateUrlWithCoordinates(lat, lng) {
        const newUrl = `${window.location.pathname}?lat=${lat}&lng=${lng}`;
        history.replaceState(null, '', newUrl);
    }




    // 출발지 주소 검색 버튼 클릭 시 좌표 입력
    document.getElementById('startAddressBtn').addEventListener('click', function() {
        new daum.Postcode({
            oncomplete: function(data) {
                geocoder.addressSearch(data.address, function(result, status) {
                    if (status === kakao.maps.services.Status.OK) {
                        var coords = new kakao.maps.LatLng(result[0].y, result[0].x);
                        document.getElementById('startLatLng').value = coords.getLat() + ', ' + coords.getLng();
                        document.getElementById('startLat').value = coords.getLat();
                        document.getElementById('startLng').value = coords.getLng();

                        // Focus the main input field
                        setTimeout(function() {
                            document.getElementById('startLatLng').focus();
                        }, 10); // Apply a small delay to avoid rendering issues

                        // Close the Postcode window manually if necessary
                        var iframe = document.querySelector("iframe");
                        if (iframe) {
                            iframe.parentNode.removeChild(iframe);  // Removes the iframe if it stays open
                        }
                    }
                });
            }
        }).open();
    });

    // 마우스 클릭 이벤트
    kakao.maps.event.addListener(map, 'click', function(mouseEvent) {
        var latlng = mouseEvent.latLng;

        // 분리된 좌표를 각각의 인풋필드에 입력
        document.getElementById('startLat').value = latlng.getLat();
        document.getElementById('startLng').value = latlng.getLng();
        document.getElementById('startLatLng').value = latlng.getLat() + ', ' + latlng.getLng();


            // URL에 선택된 좌표 반영
    updateUrlWithCoordinates(latlng.getLat(), latlng.getLng());
    });

    // 주소 검색 후 좌표 입력
    document.getElementById('startAddressBtn').addEventListener('click', function() {
        new daum.Postcode({
            oncomplete: function(data) {
                geocoder.addressSearch(data.address, function(result, status) {
                    if (status === kakao.maps.services.Status.OK) {
                        var coords = new kakao.maps.LatLng(result[0].y, result[0].x);
                        document.getElementById('startLatLng').value = coords.getLat() + ', ' + coords.getLng();
                        document.getElementById('startLat').value = coords.getLat();
                        document.getElementById('startLng').value = coords.getLng();
                    }
                });
            }
        }).open();
    });


    var subwayData = [
        {% for station in stations %}
        {
            'name': '{{ station.name }}',
            'line': '{{ station.line }}',
            'latitude': {{ station.latitude }},
            'longitude': {{ station.longitude }},
            'transfer': {{ station.transfer|yesno:"true,false" }}
        }{% if not forloop.last %},{% endif %}
        {% endfor %}
    ];


    var markers = subwayData.map(function(station) {
        var markerPosition = new kakao.maps.LatLng(station.latitude, station.longitude);

    var markerImage = null;

    // 마커 이미지 경로를 반환하는 함수
    function getMarkerImageUrlByLine(line) {
        // line이 숫자인 경우를 처리
        if (!isNaN(line)) {
            line = parseInt(line, 10);  // 숫자일 경우 정수로 변환
        }

        switch(line) {
            case 1: return "{% static 'image/Seoul_Metro_Line_1.png' %}";
            case 2: return "{% static 'image/Seoul_Metro_Line_2.png' %}";
            case 3: return "{% static 'image/Seoul_Metro_Line_3.png' %}";
            case 4: return "{% static 'image/Seoul_Metro_Line_4.png' %}";
            case 5: return "{% static 'image/Seoul_Metro_Line_5.png' %}";
            case 6: return "{% static 'image/Seoul_Metro_Line_6.png' %}";
            case 7: return "{% static 'image/Seoul_Metro_Line_7.png' %}";
            case 8: return "{% static 'image/Seoul_Metro_Line_8.png' %}";
            case 9: return "{% static 'image/Seoul_Metro_Line_9.png' %}";
            case 'Shinbundang': return "{% static 'image/Shinbundang.png' %}";
            case 'Suinbundang': return "{% static 'image/Suinbundang.png' %}";
            default: return "{% static 'image/default_marker.png' %}";  // 기본 이미지
        }
    }

    // 환승역일 경우 환승 마커 이미지 설정
    if (station.transfer) {
        markerImage = new kakao.maps.MarkerImage(
            "{% static 'image/transfer.png' %}",  // 환승 마커 이미지 경로
            new kakao.maps.Size(15, 15),
            {offset: new kakao.maps.Point(15, 15)}
        );

    } else {
        // line 값에 따라 다른 마커 이미지를 설정 (getMarkerImageUrlByLine 함수 사용)
        var imageUrl = getMarkerImageUrlByLine(station.line);
        markerImage = new kakao.maps.MarkerImage(
            imageUrl,  // line에 따른 마커 이미지 경로
            new kakao.maps.Size(20, 20),
            {offset: new kakao.maps.Point(15, 15)}
        );
    }


        // 마커 생성
        var marker = new kakao.maps.Marker({
            position: markerPosition,
            title: station.name,
            image: markerImage,
            zIndex: station.transfer ? 10 : 0
        });

        // 정보창 생성
        var infowindow = new kakao.maps.InfoWindow({
            content: `<div style="padding:5px;"> ${station.name} (${station.line}호선) </div>`
        });

          // 마커 클릭 시 해당 역 정보를 result 영역에 표시
        kakao.maps.event.addListener(marker, 'click', function() {
            fetchStationDetails(station.name, station.line);
        });

        return marker;
    });

    markers.forEach(function(marker) {
        marker.setMap(map); // 마커를 지도에 직접 추가
    });

    // 결과를 삭제하는 함수
    function deleteResult(resultId) {
        const resultItem = document.getElementById(resultId);
        if (resultItem) {
            resultItem.remove();  // 해당 결과를 삭제
        }
    }

    // 서버에서 선택된 역 정보를 가져오는 함수
    function fetchStationDetails(stationName, stationLine) {
        fetch(`/stations/${stationName}/${stationLine}/`)  // 선택된 역 이름과 노선을 URL로 전송
            .then(response => response.json())
            .then(data => {
                // 데이터를 화면에 표시 (기존 함수 호출)
                displayStationInfo(data);

                // Store the selected station's information
                selectedStation = data;

                // Populate the fields with the selected station's information
                document.getElementById('startLat').value = data.latitude;
                document.getElementById('startLng').value = data.longitude;
                document.getElementById('name').value = data.name;
                document.getElementById('line').value = data.line;
            })
            .catch(error => {
                console.error('역 정보를 가져오는 중 오류 발생:', error);
            });
    }
    // Reset input fields and displayed station info
    function resetInputFields() {
        document.getElementById('startLat').value = '';
        document.getElementById('startLng').value = '';
        document.getElementById('name').value = '';
        document.getElementById('line').value = '';
        document.getElementById('result').innerHTML = ''; // 표시된 역 정보 초기화
        selectedStation = null;  // 선택된 역 정보 초기화
    }


    // Add a new station, with an optional "before" or "after" position
    document.getElementById('addStationButton').addEventListener('click', function() {
        const name = document.getElementById('name').value;
        const line = document.getElementById('line').value;
        const latitude = parseFloat(document.getElementById('startLat').value);
        const longitude = parseFloat(document.getElementById('startLng').value);

        if (!name || isNaN(latitude) || isNaN(longitude)) {
            alert("모든 필드를 채워주세요.");
            return;
        }

        // Get the selected position (either 'before' or 'after')
        const position = document.getElementById('position').value;

        // Show message if no line is selected
        if (!line) {
            document.getElementById('lineInfoMessage').style.display = 'block';
        } else {
            document.getElementById('lineInfoMessage').style.display = 'none';
        }

        // Check if selected station exists and if the line matches
        if (selectedStation && selectedStation.line !== line) {
            alert("선택한 역과 라인이 일치하지 않습니다. 같은 노선에만 추가할 수 있습니다.");
            return;
        }

        // Prepare the new station data, including the sort order from the selected station if any
        const newStation = {
            name: name,
            line: line,
            latitude: latitude,
            longitude: longitude,
            position: position
        };

        // Include selected station's sort order if available
        if (selectedStation && selectedStation.sort_order) {
            newStation.selectedStationSortOrder = selectedStation.sort_order;
        }

        // Perform the fetch request to add the new station
        fetch('/stations/add/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCSRFToken()  // Include CSRF token if required
            },
            body: JSON.stringify(newStation)
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(data => { throw new Error(data.message); });
            }
            return response.json();
        })
        .then(data => {
            alert("새 역이 추가되었습니다!");
            resetInputFields()
            console.log(data);
            location.reload();  // 페이지 새로고침
        })
        .catch(error => {
            alert(error.message);
            console.error('Error adding station:', error);
        });
    });

    // Delete the selected station
    document.getElementById('deleteStationButton').addEventListener('click', function() {
        if (!selectedStation || !selectedStation.name || !selectedStation.line) {
            alert("먼저 삭제할 역을 선택하세요.");
            return;
        }

        // Confirm deletion
        if (!confirm('정말로 삭제하시겠습니까?')) {
            return;
        }

        // Send DELETE request to the server using name and line
        fetch(`/stations/delete/${selectedStation.name}/${selectedStation.line}/`, {
            method: 'DELETE',
            headers: {
                'X-CSRFToken': getCSRFToken()  // Include CSRF token if required
            }
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Failed to delete station');
            }
            return response.json();
        })
        .then(data => {
            alert("역이 삭제되었습니다.");
            resetInputFields()
            console.log(data);
            location.reload();  // 페이지 새로고침

            // Optionally, reset the form or reload the station list
        })
        .catch(error => {
            console.error('Error deleting station:', error);
            alert("역 삭제 중 오류가 발생했습니다.");
        });
    });

    // 역 정보를 화면에 간결하게 표시하는 함수
    function displayStationInfo(station) {
        const resultDiv = document.getElementById('result');
        resultDiv.innerHTML = `
            <strong>기준 역 정보: </strong>
            <span>name: <span class="value">${station.name}</span></span> |
            <span>line: <span class="value">${station.line}</span></span> |
            <span>lat: <span class="value">${station.latitude.toFixed(4)}</span></span> |
            <span>long: <span class="value">${station.longitude.toFixed(4)}</span></span> |
            <span>order: <span class="value">${station.sort_order}</span></span>
        `;
    }

    // 페이지 로드 시 역 데이터를 가져옴
    window.onload = function() {
       location.reload();  // 페이지 새로고침
    };

    // Reset button functionality to clear input fields
    document.getElementById('resetButton').addEventListener('click', function() {
        document.getElementById('startLat').value = '';
        document.getElementById('startLng').value = '';
        document.getElementById('name').value = '';
        document.getElementById('line').value = '';
        selectedStation = null;  // Clear the selected station
    });

    // 팝업 및 오버레이 요소 가져오기
    const showImagesButton = document.getElementById('showImagesButton');
    const popup = document.getElementById('imagePopup');
    const overlay = document.getElementById('overlay');
    const closePopup = document.getElementById('closePopup');
    const imageList = document.getElementById('imageList');

    // 팝업 열기
    showImagesButton.addEventListener('click', () => {
        fetch('/get_line_images/')
            .then(response => response.json())
            .then(data => {
                imageList.innerHTML = ''; // 기존 이미지 목록 초기화
                data.images.forEach(image => {
                    const imgElement = document.createElement('img');
                    imgElement.src = image.url;
                    imgElement.alt = image.name;
                    imageList.appendChild(imgElement);
                });
                popup.style.display = 'block';
                overlay.style.display = 'block';
            })
            .catch(error => {
                console.error('이미지 로드 중 오류 발생:', error);
            });
    });

    // 팝업 닫기
    closePopup.addEventListener('click', () => {
        popup.style.display = 'none';
        overlay.style.display = 'none';
    });

    overlay.addEventListener('click', () => {
        popup.style.display = 'none';
        overlay.style.display = 'none';
    });


document.getElementById('addNewLineButton').addEventListener('click', function() {
    const name = document.getElementById('name').value;
    const line = document.getElementById('line').value;
    const latitude = parseFloat(document.getElementById('startLat').value);
    const longitude = parseFloat(document.getElementById('startLng').value);

    if (!name || isNaN(latitude) || isNaN(longitude) || !line) {
        alert("모든 필드를 채워주세요.");
        return;
    }

    // 새로운 역 데이터를 준비합니다
    const newStation = {
        name: name,
        line: line,
        latitude: latitude,
        longitude: longitude
    };

    // 서버로 새로운 라인을 추가 요청합니다
    fetch('/stations/add_new_line/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCSRFToken()  // CSRF 토큰 포함
        },
        body: JSON.stringify(newStation)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(data => { throw new Error(data.message); });
        }
        return response.json();
    })
    .then(data => {
        alert("신규 라인이 추가되었습니다!");
        resetInputFields();
        console.log(data);
        location.reload();  // 페이지 새로고침
    })
    .catch(error => {
        alert("신규 라인 추가 중 오류가 발생했습니다: " + error.message);
        console.error('Error adding new line:', error);
    });
});

    // Helper function to get the CSRF token
    function getCSRFToken() {
        let csrfToken = null;
        const cookies = document.cookie.split(';');
        cookies.forEach(cookie => {
            const [name, value] = cookie.trim().split('=');
            if (name === 'csrftoken') {
                csrfToken = value;
            }
        });
        return csrfToken;
    }
    </script>

</body>
</html>